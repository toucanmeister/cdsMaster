
/**
 * @file node_basic.c
 *
 * Functions to allocate node structures
 * 
 * THIS FILE HAS BEEN GENERATED USING 
 * $Id: node_basic.c.xsl 14593 2006-01-31 17:09:55Z cg $.
 * DO NOT EDIT THIS FILE AS MIGHT BE CHANGED IN A LATER VERSION.
 *
 * ALL CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN!
 *
 */

#include "node_basic.h"
#include "tree_basic.h"
#include "memory.h"
#include "dbug.h"
#include "globals.h"
#include "ctinfo.h"

static node *
MakeEmptyNode ()
{
  node *result;

  DBUG_ENTER ("MakeEmptyNode");

  result = (node *) MEMmalloc (sizeof (node));

  NODE_LINE (result) = global.line;
  NODE_COL (result) = global.col;

  DBUG_RETURN (result);
}



/*****************************************************************************
 * N_Module :
 *****************************************************************************/

node *
TBmakeModule (char *name, node * Declarations)
{
  node *this;
  DBUG_ENTER ("TBmakeModule");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_module;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_module = MEMmalloc (sizeof (struct SONS_N_MODULE));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_module = MEMmalloc (sizeof (struct ATTRIBS_N_MODULE));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_module;
  DBUG_PRINT ("MAKE",
	      ("assigning son Declarations initial value: %s ",
	       Declarations));
  MODULE_DECLARATIONS (this) = Declarations;
  MODULE_NAME (this) = name;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((MODULE_DECLARATIONS (this) != NULL)
      && (NODE_TYPE (MODULE_DECLARATIONS (this)) != N_decblock))
    {
      CTIwarn
	("Field Declarations of node N_Module has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_DecBlock :
 *****************************************************************************/

node *
TBmakeDecblock (node * This, node * Next)
{
  node *this;
  DBUG_ENTER ("TBmakeDecblock");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_decblock;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_decblock = MEMmalloc (sizeof (struct SONS_N_DECBLOCK));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_decblock = MEMmalloc (sizeof (struct ATTRIBS_N_DECBLOCK));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_decblock;
  DBUG_PRINT ("MAKE", ("assigning son This initial value: %s ", This));
  DECBLOCK_THIS (this) = This;
  DBUG_PRINT ("MAKE", ("assigning son Next initial value: %s ", Next));
  DECBLOCK_NEXT (this) = Next;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((DECBLOCK_THIS (this) != NULL)
      && (NODE_TYPE (DECBLOCK_THIS (this)) != N_fundec)
      && (NODE_TYPE (DECBLOCK_THIS (this)) != N_vardec))
    {
      CTIwarn ("Field This of node N_DecBlock has non-allowed target node.");
    }
  if ((DECBLOCK_NEXT (this) != NULL)
      && (NODE_TYPE (DECBLOCK_NEXT (this)) != N_decblock))
    {
      CTIwarn ("Field Next of node N_DecBlock has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_FunDec :
 *****************************************************************************/

node *
TBmakeFundec (char *Name, node * Params, node * Body)
{
  node *this;
  DBUG_ENTER ("TBmakeFundec");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_fundec;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_fundec = MEMmalloc (sizeof (struct SONS_N_FUNDEC));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_fundec = MEMmalloc (sizeof (struct ATTRIBS_N_FUNDEC));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_fundec;
  DBUG_PRINT ("MAKE", ("assigning son Params initial value: %s ", Params));
  FUNDEC_PARAMS (this) = Params;
  DBUG_PRINT ("MAKE", ("assigning son Body initial value: %s ", Body));
  FUNDEC_BODY (this) = Body;
  FUNDEC_NAME (this) = Name;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((FUNDEC_PARAMS (this) != NULL)
      && (NODE_TYPE (FUNDEC_PARAMS (this)) != N_funparams))
    {
      CTIwarn ("Field Params of node N_FunDec has non-allowed target node.");
    }
  if ((FUNDEC_BODY (this) != NULL)
      && (NODE_TYPE (FUNDEC_BODY (this)) != N_funbody))
    {
      CTIwarn ("Field Body of node N_FunDec has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_FunParams :
 *****************************************************************************/

node *
TBmakeFunparams (node * This, node * Next)
{
  node *this;
  DBUG_ENTER ("TBmakeFunparams");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_funparams;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_funparams = MEMmalloc (sizeof (struct SONS_N_FUNPARAMS));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_funparams = MEMmalloc (sizeof (struct ATTRIBS_N_FUNPARAMS));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_funparams;
  DBUG_PRINT ("MAKE", ("assigning son This initial value: %s ", This));
  FUNPARAMS_THIS (this) = This;
  DBUG_PRINT ("MAKE", ("assigning son Next initial value: %s ", Next));
  FUNPARAMS_NEXT (this) = Next;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((FUNPARAMS_THIS (this) != NULL)
      && (NODE_TYPE (FUNPARAMS_THIS (this)) != N_funparam))
    {
      CTIwarn ("Field This of node N_FunParams has non-allowed target node.");
    }
  if ((FUNPARAMS_NEXT (this) != NULL)
      && (NODE_TYPE (FUNPARAMS_NEXT (this)) != N_funparams))
    {
      CTIwarn ("Field Next of node N_FunParams has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_FunParam :
 *****************************************************************************/

node *
TBmakeFunparam (char *Name, cvctype Type)
{
  node *this;
  DBUG_ENTER ("TBmakeFunparam");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_funparam;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_funparam = MEMmalloc (sizeof (struct SONS_N_FUNPARAM));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_funparam = MEMmalloc (sizeof (struct ATTRIBS_N_FUNPARAM));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_funparam;
  FUNPARAM_NAME (this) = Name;
  FUNPARAM_TYPE (this) = Type;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_FunBody :
 *****************************************************************************/

node *
TBmakeFunbody (node * Declarations, node * Statements)
{
  node *this;
  DBUG_ENTER ("TBmakeFunbody");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_funbody;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_funbody = MEMmalloc (sizeof (struct SONS_N_FUNBODY));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_funbody = MEMmalloc (sizeof (struct ATTRIBS_N_FUNBODY));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_funbody;
  DBUG_PRINT ("MAKE",
	      ("assigning son Declarations initial value: %s ",
	       Declarations));
  FUNBODY_DECLARATIONS (this) = Declarations;
  DBUG_PRINT ("MAKE",
	      ("assigning son Statements initial value: %s ", Statements));
  FUNBODY_STATEMENTS (this) = Statements;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((FUNBODY_DECLARATIONS (this) != NULL)
      && (NODE_TYPE (FUNBODY_DECLARATIONS (this)) != N_decblock))
    {
      CTIwarn
	("Field Declarations of node N_FunBody has non-allowed target node.");
    }
  if ((FUNBODY_STATEMENTS (this) != NULL)
      && (NODE_TYPE (FUNBODY_STATEMENTS (this)) != N_block))
    {
      CTIwarn
	("Field Statements of node N_FunBody has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_VarDec :
 *****************************************************************************/

node *
TBmakeVardec (char *Name, node * Expression)
{
  node *this;
  DBUG_ENTER ("TBmakeVardec");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_vardec;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_vardec = MEMmalloc (sizeof (struct SONS_N_VARDEC));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_vardec = MEMmalloc (sizeof (struct ATTRIBS_N_VARDEC));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_vardec;
  DBUG_PRINT ("MAKE",
	      ("assigning son Expression initial value: %s ", Expression));
  VARDEC_EXPRESSION (this) = Expression;
  VARDEC_NAME (this) = Name;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((VARDEC_EXPRESSION (this) != NULL)
      && (NODE_TYPE (VARDEC_EXPRESSION (this)) != N_binop)
      && (NODE_TYPE (VARDEC_EXPRESSION (this)) != N_monop)
      && (NODE_TYPE (VARDEC_EXPRESSION (this)) != N_cast)
      && (NODE_TYPE (VARDEC_EXPRESSION (this)) != N_funcall)
      && (NODE_TYPE (VARDEC_EXPRESSION (this)) != N_variable)
      && (NODE_TYPE (VARDEC_EXPRESSION (this)) != N_intconst)
      && (NODE_TYPE (VARDEC_EXPRESSION (this)) != N_floatconst)
      && (NODE_TYPE (VARDEC_EXPRESSION (this)) != N_boolconst))
    {
      CTIwarn
	("Field Expression of node N_VarDec has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Block :
 *****************************************************************************/

node *
TBmakeBlock (node * This, node * Next)
{
  node *this;
  DBUG_ENTER ("TBmakeBlock");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_block;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_block = MEMmalloc (sizeof (struct SONS_N_BLOCK));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_block = MEMmalloc (sizeof (struct ATTRIBS_N_BLOCK));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_block;
  DBUG_PRINT ("MAKE", ("assigning son This initial value: %s ", This));
  BLOCK_THIS (this) = This;
  DBUG_PRINT ("MAKE", ("assigning son Next initial value: %s ", Next));
  BLOCK_NEXT (this) = Next;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((BLOCK_THIS (this) != NULL)
      && (NODE_TYPE (BLOCK_THIS (this)) != N_assign)
      && (NODE_TYPE (BLOCK_THIS (this)) != N_proccall)
      && (NODE_TYPE (BLOCK_THIS (this)) != N_if)
      && (NODE_TYPE (BLOCK_THIS (this)) != N_while)
      && (NODE_TYPE (BLOCK_THIS (this)) != N_dowhile)
      && (NODE_TYPE (BLOCK_THIS (this)) != N_for)
      && (NODE_TYPE (BLOCK_THIS (this)) != N_return))
    {
      CTIwarn ("Field This of node N_Block has non-allowed target node.");
    }
  if ((BLOCK_NEXT (this) != NULL)
      && (NODE_TYPE (BLOCK_NEXT (this)) != N_block))
    {
      CTIwarn ("Field Next of node N_Block has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Assign :
 *****************************************************************************/

node *
TBmakeAssign (char *Name, node * Expression)
{
  node *this;
  DBUG_ENTER ("TBmakeAssign");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_assign;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_assign = MEMmalloc (sizeof (struct SONS_N_ASSIGN));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_assign = MEMmalloc (sizeof (struct ATTRIBS_N_ASSIGN));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_assign;
  DBUG_PRINT ("MAKE",
	      ("assigning son Expression initial value: %s ", Expression));
  ASSIGN_EXPRESSION (this) = Expression;
  ASSIGN_NAME (this) = Name;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((ASSIGN_EXPRESSION (this) != NULL)
      && (NODE_TYPE (ASSIGN_EXPRESSION (this)) != N_binop)
      && (NODE_TYPE (ASSIGN_EXPRESSION (this)) != N_monop)
      && (NODE_TYPE (ASSIGN_EXPRESSION (this)) != N_cast)
      && (NODE_TYPE (ASSIGN_EXPRESSION (this)) != N_funcall)
      && (NODE_TYPE (ASSIGN_EXPRESSION (this)) != N_variable)
      && (NODE_TYPE (ASSIGN_EXPRESSION (this)) != N_intconst)
      && (NODE_TYPE (ASSIGN_EXPRESSION (this)) != N_floatconst)
      && (NODE_TYPE (ASSIGN_EXPRESSION (this)) != N_boolconst))
    {
      CTIwarn
	("Field Expression of node N_Assign has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_ProcCall :
 *****************************************************************************/

node *
TBmakeProccall (char *Name, node * Args)
{
  node *this;
  DBUG_ENTER ("TBmakeProccall");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_proccall;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_proccall = MEMmalloc (sizeof (struct SONS_N_PROCCALL));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_proccall = MEMmalloc (sizeof (struct ATTRIBS_N_PROCCALL));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_proccall;
  DBUG_PRINT ("MAKE", ("assigning son Args initial value: %s ", Args));
  PROCCALL_ARGS (this) = Args;
  PROCCALL_NAME (this) = Name;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((PROCCALL_ARGS (this) != NULL)
      && (NODE_TYPE (PROCCALL_ARGS (this)) != N_funargs))
    {
      CTIwarn ("Field Args of node N_ProcCall has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_If :
 *****************************************************************************/

node *
TBmakeIf (node * Condition, node * Then, node * Else)
{
  node *this;
  DBUG_ENTER ("TBmakeIf");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_if;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_if = MEMmalloc (sizeof (struct SONS_N_IF));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_if = MEMmalloc (sizeof (struct ATTRIBS_N_IF));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_if;
  DBUG_PRINT ("MAKE",
	      ("assigning son Condition initial value: %s ", Condition));
  IF_CONDITION (this) = Condition;
  DBUG_PRINT ("MAKE", ("assigning son Then initial value: %s ", Then));
  IF_THEN (this) = Then;
  DBUG_PRINT ("MAKE", ("assigning son Else initial value: %s ", Else));
  IF_ELSE (this) = Else;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((IF_CONDITION (this) != NULL)
      && (NODE_TYPE (IF_CONDITION (this)) != N_binop)
      && (NODE_TYPE (IF_CONDITION (this)) != N_monop)
      && (NODE_TYPE (IF_CONDITION (this)) != N_cast)
      && (NODE_TYPE (IF_CONDITION (this)) != N_funcall)
      && (NODE_TYPE (IF_CONDITION (this)) != N_variable)
      && (NODE_TYPE (IF_CONDITION (this)) != N_intconst)
      && (NODE_TYPE (IF_CONDITION (this)) != N_floatconst)
      && (NODE_TYPE (IF_CONDITION (this)) != N_boolconst))
    {
      CTIwarn ("Field Condition of node N_If has non-allowed target node.");
    }
  if ((IF_THEN (this) != NULL))
    {
      CTIwarn ("Field Then of node N_If has non-allowed target node.");
    }
  if ((IF_ELSE (this) != NULL) && (NODE_TYPE (IF_ELSE (this)) != N_block))
    {
      CTIwarn ("Field Else of node N_If has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_While :
 *****************************************************************************/

node *
TBmakeWhile (node * Condition, node * Body)
{
  node *this;
  DBUG_ENTER ("TBmakeWhile");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_while;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_while = MEMmalloc (sizeof (struct SONS_N_WHILE));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_while = MEMmalloc (sizeof (struct ATTRIBS_N_WHILE));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_while;
  DBUG_PRINT ("MAKE",
	      ("assigning son Condition initial value: %s ", Condition));
  WHILE_CONDITION (this) = Condition;
  DBUG_PRINT ("MAKE", ("assigning son Body initial value: %s ", Body));
  WHILE_BODY (this) = Body;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((WHILE_CONDITION (this) != NULL)
      && (NODE_TYPE (WHILE_CONDITION (this)) != N_binop)
      && (NODE_TYPE (WHILE_CONDITION (this)) != N_monop)
      && (NODE_TYPE (WHILE_CONDITION (this)) != N_cast)
      && (NODE_TYPE (WHILE_CONDITION (this)) != N_funcall)
      && (NODE_TYPE (WHILE_CONDITION (this)) != N_variable)
      && (NODE_TYPE (WHILE_CONDITION (this)) != N_intconst)
      && (NODE_TYPE (WHILE_CONDITION (this)) != N_floatconst)
      && (NODE_TYPE (WHILE_CONDITION (this)) != N_boolconst))
    {
      CTIwarn
	("Field Condition of node N_While has non-allowed target node.");
    }
  if ((WHILE_BODY (this) != NULL)
      && (NODE_TYPE (WHILE_BODY (this)) != N_block))
    {
      CTIwarn ("Field Body of node N_While has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_DoWhile :
 *****************************************************************************/

node *
TBmakeDowhile (node * Condition, node * Body)
{
  node *this;
  DBUG_ENTER ("TBmakeDowhile");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_dowhile;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_dowhile = MEMmalloc (sizeof (struct SONS_N_DOWHILE));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_dowhile = MEMmalloc (sizeof (struct ATTRIBS_N_DOWHILE));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_dowhile;
  DBUG_PRINT ("MAKE",
	      ("assigning son Condition initial value: %s ", Condition));
  DOWHILE_CONDITION (this) = Condition;
  DBUG_PRINT ("MAKE", ("assigning son Body initial value: %s ", Body));
  DOWHILE_BODY (this) = Body;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((DOWHILE_CONDITION (this) != NULL)
      && (NODE_TYPE (DOWHILE_CONDITION (this)) != N_binop)
      && (NODE_TYPE (DOWHILE_CONDITION (this)) != N_monop)
      && (NODE_TYPE (DOWHILE_CONDITION (this)) != N_cast)
      && (NODE_TYPE (DOWHILE_CONDITION (this)) != N_funcall)
      && (NODE_TYPE (DOWHILE_CONDITION (this)) != N_variable)
      && (NODE_TYPE (DOWHILE_CONDITION (this)) != N_intconst)
      && (NODE_TYPE (DOWHILE_CONDITION (this)) != N_floatconst)
      && (NODE_TYPE (DOWHILE_CONDITION (this)) != N_boolconst))
    {
      CTIwarn
	("Field Condition of node N_DoWhile has non-allowed target node.");
    }
  if ((DOWHILE_BODY (this) != NULL)
      && (NODE_TYPE (DOWHILE_BODY (this)) != N_block))
    {
      CTIwarn ("Field Body of node N_DoWhile has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_For :
 *****************************************************************************/

node *
TBmakeFor (node * Start, node * Stop, node * Step, node * Body)
{
  node *this;
  DBUG_ENTER ("TBmakeFor");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_for;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_for = MEMmalloc (sizeof (struct SONS_N_FOR));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_for = MEMmalloc (sizeof (struct ATTRIBS_N_FOR));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_for;
  DBUG_PRINT ("MAKE", ("assigning son Start initial value: %s ", Start));
  FOR_START (this) = Start;
  DBUG_PRINT ("MAKE", ("assigning son Stop initial value: %s ", Stop));
  FOR_STOP (this) = Stop;
  DBUG_PRINT ("MAKE", ("assigning son Step initial value: %s ", Step));
  FOR_STEP (this) = Step;
  DBUG_PRINT ("MAKE", ("assigning son Body initial value: %s ", Body));
  FOR_BODY (this) = Body;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((FOR_START (this) != NULL)
      && (NODE_TYPE (FOR_START (this)) != N_expression))
    {
      CTIwarn ("Field Start of node N_For has non-allowed target node.");
    }
  if ((FOR_STOP (this) != NULL)
      && (NODE_TYPE (FOR_STOP (this)) != N_expression))
    {
      CTIwarn ("Field Stop of node N_For has non-allowed target node.");
    }
  if ((FOR_STEP (this) != NULL)
      && (NODE_TYPE (FOR_STEP (this)) != N_expression))
    {
      CTIwarn ("Field Step of node N_For has non-allowed target node.");
    }
  if ((FOR_BODY (this) != NULL) && (NODE_TYPE (FOR_BODY (this)) != N_block))
    {
      CTIwarn ("Field Body of node N_For has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Return :
 *****************************************************************************/

node *
TBmakeReturn (node * Expression)
{
  node *this;
  DBUG_ENTER ("TBmakeReturn");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_return;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_return = MEMmalloc (sizeof (struct SONS_N_RETURN));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_return = MEMmalloc (sizeof (struct ATTRIBS_N_RETURN));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_return;
  DBUG_PRINT ("MAKE",
	      ("assigning son Expression initial value: %s ", Expression));
  RETURN_EXPRESSION (this) = Expression;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((RETURN_EXPRESSION (this) != NULL)
      && (NODE_TYPE (RETURN_EXPRESSION (this)) != N_binop)
      && (NODE_TYPE (RETURN_EXPRESSION (this)) != N_monop)
      && (NODE_TYPE (RETURN_EXPRESSION (this)) != N_cast)
      && (NODE_TYPE (RETURN_EXPRESSION (this)) != N_funcall)
      && (NODE_TYPE (RETURN_EXPRESSION (this)) != N_variable)
      && (NODE_TYPE (RETURN_EXPRESSION (this)) != N_intconst)
      && (NODE_TYPE (RETURN_EXPRESSION (this)) != N_floatconst)
      && (NODE_TYPE (RETURN_EXPRESSION (this)) != N_boolconst))
    {
      CTIwarn
	("Field Expression of node N_Return has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_BinOp :
 *****************************************************************************/

node *
TBmakeBinop (binop Operator, node * Left, node * Right)
{
  node *this;
  DBUG_ENTER ("TBmakeBinop");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_binop;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_binop = MEMmalloc (sizeof (struct SONS_N_BINOP));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_binop = MEMmalloc (sizeof (struct ATTRIBS_N_BINOP));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_binop;
  DBUG_PRINT ("MAKE", ("assigning son Left initial value: %s ", Left));
  BINOP_LEFT (this) = Left;
  DBUG_PRINT ("MAKE", ("assigning son Right initial value: %s ", Right));
  BINOP_RIGHT (this) = Right;
  BINOP_OPERATOR (this) = Operator;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((BINOP_LEFT (this) != NULL)
      && (NODE_TYPE (BINOP_LEFT (this)) != N_binop)
      && (NODE_TYPE (BINOP_LEFT (this)) != N_monop)
      && (NODE_TYPE (BINOP_LEFT (this)) != N_cast)
      && (NODE_TYPE (BINOP_LEFT (this)) != N_funcall)
      && (NODE_TYPE (BINOP_LEFT (this)) != N_variable)
      && (NODE_TYPE (BINOP_LEFT (this)) != N_intconst)
      && (NODE_TYPE (BINOP_LEFT (this)) != N_floatconst)
      && (NODE_TYPE (BINOP_LEFT (this)) != N_boolconst))
    {
      CTIwarn ("Field Left of node N_BinOp has non-allowed target node.");
    }
  if ((BINOP_RIGHT (this) != NULL)
      && (NODE_TYPE (BINOP_RIGHT (this)) != N_binop)
      && (NODE_TYPE (BINOP_RIGHT (this)) != N_monop)
      && (NODE_TYPE (BINOP_RIGHT (this)) != N_cast)
      && (NODE_TYPE (BINOP_RIGHT (this)) != N_funcall)
      && (NODE_TYPE (BINOP_RIGHT (this)) != N_variable)
      && (NODE_TYPE (BINOP_RIGHT (this)) != N_intconst)
      && (NODE_TYPE (BINOP_RIGHT (this)) != N_floatconst)
      && (NODE_TYPE (BINOP_RIGHT (this)) != N_boolconst))
    {
      CTIwarn ("Field Right of node N_BinOp has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_MonOp :
 *****************************************************************************/

node *
TBmakeMonop (monop Operator, node * Operand)
{
  node *this;
  DBUG_ENTER ("TBmakeMonop");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_monop;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_monop = MEMmalloc (sizeof (struct SONS_N_MONOP));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_monop = MEMmalloc (sizeof (struct ATTRIBS_N_MONOP));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_monop;
  DBUG_PRINT ("MAKE", ("assigning son Operand initial value: %s ", Operand));
  MONOP_OPERAND (this) = Operand;
  MONOP_OPERATOR (this) = Operator;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((MONOP_OPERAND (this) != NULL)
      && (NODE_TYPE (MONOP_OPERAND (this)) != N_binop)
      && (NODE_TYPE (MONOP_OPERAND (this)) != N_monop)
      && (NODE_TYPE (MONOP_OPERAND (this)) != N_cast)
      && (NODE_TYPE (MONOP_OPERAND (this)) != N_funcall)
      && (NODE_TYPE (MONOP_OPERAND (this)) != N_variable)
      && (NODE_TYPE (MONOP_OPERAND (this)) != N_intconst)
      && (NODE_TYPE (MONOP_OPERAND (this)) != N_floatconst)
      && (NODE_TYPE (MONOP_OPERAND (this)) != N_boolconst))
    {
      CTIwarn ("Field Operand of node N_MonOp has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Cast :
 *****************************************************************************/

node *
TBmakeCast (cvctype Type, node * Expression)
{
  node *this;
  DBUG_ENTER ("TBmakeCast");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_cast;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_cast = MEMmalloc (sizeof (struct SONS_N_CAST));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_cast = MEMmalloc (sizeof (struct ATTRIBS_N_CAST));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_cast;
  DBUG_PRINT ("MAKE",
	      ("assigning son Expression initial value: %s ", Expression));
  CAST_EXPRESSION (this) = Expression;
  CAST_TYPE (this) = Type;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((CAST_EXPRESSION (this) != NULL)
      && (NODE_TYPE (CAST_EXPRESSION (this)) != N_binop)
      && (NODE_TYPE (CAST_EXPRESSION (this)) != N_monop)
      && (NODE_TYPE (CAST_EXPRESSION (this)) != N_cast)
      && (NODE_TYPE (CAST_EXPRESSION (this)) != N_funcall)
      && (NODE_TYPE (CAST_EXPRESSION (this)) != N_variable)
      && (NODE_TYPE (CAST_EXPRESSION (this)) != N_intconst)
      && (NODE_TYPE (CAST_EXPRESSION (this)) != N_floatconst)
      && (NODE_TYPE (CAST_EXPRESSION (this)) != N_boolconst))
    {
      CTIwarn
	("Field Expression of node N_Cast has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_FunCall :
 *****************************************************************************/

node *
TBmakeFuncall (char *Name, node * Args)
{
  node *this;
  DBUG_ENTER ("TBmakeFuncall");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_funcall;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_funcall = MEMmalloc (sizeof (struct SONS_N_FUNCALL));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_funcall = MEMmalloc (sizeof (struct ATTRIBS_N_FUNCALL));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_funcall;
  DBUG_PRINT ("MAKE", ("assigning son Args initial value: %s ", Args));
  FUNCALL_ARGS (this) = Args;
  FUNCALL_NAME (this) = Name;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((FUNCALL_ARGS (this) != NULL)
      && (NODE_TYPE (FUNCALL_ARGS (this)) != N_funargs))
    {
      CTIwarn ("Field Args of node N_FunCall has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_FunArgs :
 *****************************************************************************/

node *
TBmakeFunargs (node * This, node * Next)
{
  node *this;
  DBUG_ENTER ("TBmakeFunargs");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_funargs;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_funargs = MEMmalloc (sizeof (struct SONS_N_FUNARGS));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_funargs = MEMmalloc (sizeof (struct ATTRIBS_N_FUNARGS));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_funargs;
  DBUG_PRINT ("MAKE", ("assigning son This initial value: %s ", This));
  FUNARGS_THIS (this) = This;
  DBUG_PRINT ("MAKE", ("assigning son Next initial value: %s ", Next));
  FUNARGS_NEXT (this) = Next;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((FUNARGS_THIS (this) != NULL)
      && (NODE_TYPE (FUNARGS_THIS (this)) != N_binop)
      && (NODE_TYPE (FUNARGS_THIS (this)) != N_monop)
      && (NODE_TYPE (FUNARGS_THIS (this)) != N_cast)
      && (NODE_TYPE (FUNARGS_THIS (this)) != N_funcall)
      && (NODE_TYPE (FUNARGS_THIS (this)) != N_variable)
      && (NODE_TYPE (FUNARGS_THIS (this)) != N_intconst)
      && (NODE_TYPE (FUNARGS_THIS (this)) != N_floatconst)
      && (NODE_TYPE (FUNARGS_THIS (this)) != N_boolconst))
    {
      CTIwarn ("Field This of node N_FunArgs has non-allowed target node.");
    }
  if ((FUNARGS_NEXT (this) != NULL)
      && (NODE_TYPE (FUNARGS_NEXT (this)) != N_funargs))
    {
      CTIwarn ("Field Next of node N_FunArgs has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Variable :
 *****************************************************************************/

node *
TBmakeVariable (char *Name)
{
  node *this;
  DBUG_ENTER ("TBmakeVariable");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_variable;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_variable = MEMmalloc (sizeof (struct SONS_N_VARIABLE));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_variable = MEMmalloc (sizeof (struct ATTRIBS_N_VARIABLE));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_variable;
  VARIABLE_NAME (this) = Name;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_IntConst :
 *****************************************************************************/

node *
TBmakeIntconst (int Value)
{
  node *this;
  DBUG_ENTER ("TBmakeIntconst");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_intconst;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_intconst = MEMmalloc (sizeof (struct SONS_N_INTCONST));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_intconst = MEMmalloc (sizeof (struct ATTRIBS_N_INTCONST));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_intconst;
  INTCONST_VALUE (this) = Value;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_FloatConst :
 *****************************************************************************/

node *
TBmakeFloatconst (float Value)
{
  node *this;
  DBUG_ENTER ("TBmakeFloatconst");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_floatconst;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_floatconst = MEMmalloc (sizeof (struct SONS_N_FLOATCONST));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_floatconst =
    MEMmalloc (sizeof (struct ATTRIBS_N_FLOATCONST));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_floatconst;
  FLOATCONST_VALUE (this) = Value;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_BoolConst :
 *****************************************************************************/

node *
TBmakeBoolconst (bool Value)
{
  node *this;
  DBUG_ENTER ("TBmakeBoolconst");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_boolconst;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_boolconst = MEMmalloc (sizeof (struct SONS_N_BOOLCONST));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_boolconst = MEMmalloc (sizeof (struct ATTRIBS_N_BOOLCONST));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_boolconst;
  BOOLCONST_VALUE (this) = Value;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

  /* end of file */
