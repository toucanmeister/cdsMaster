
/**
 * @file check.c
 *
 * Functions needed by check.
 * 
 * THIS FILE HAS BEEN GENERATED USING 
 * $Id: check.c.xsl 14618 2006-02-28 16:08:17Z                                jhb $.
 * DO NOT EDIT THIS FILE AS MIGHT BE CHANGED IN A LATER VERSION.
 *
 * ALL CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN!
 *
 */

/**
 * @defgroup check Check tree Functions
 *
 * Functions needed by check traversal.
 *
 * @{
 */


#include "check.h"
#include "globals.h"
#include "tree_basic.h"
#include "traverse.h"
#include "dbug.h"
#include "print.h"
#include "check_lib.h"
#include "free.h"
#include "str.h"
#include "memory.h"

/*****************************************************************************
 *
 * @fn node *CHKdoTreeCheck( node *syntax_tree)
 *
 ****************************************************************************/
node *
CHKdoTreeCheck (node * syntax_tree)
{
  DBUG_ENTER ("CHKdoTreeCheck");

  DBUG_PRINT ("CHK", ("Starting the check mechanism"));

  TRAVpush (TR_chk);
  syntax_tree = TRAVdo (syntax_tree, NULL);
  TRAVpop ();

  DBUG_PRINT ("CHK", ("Checkmechanism complete"));

  DBUG_RETURN (syntax_tree);
}

static bool
isDec (node * arg_node)
{
  bool res = ((NODE_TYPE (arg_node) == N_fundec) ||
	      (NODE_TYPE (arg_node) == N_vardec));
  return (res);
}

static bool
isExpression (node * arg_node)
{
  bool res = ((NODE_TYPE (arg_node) == N_binop) ||
	      (NODE_TYPE (arg_node) == N_boolconst) ||
	      (NODE_TYPE (arg_node) == N_cast) ||
	      (NODE_TYPE (arg_node) == N_floatconst) ||
	      (NODE_TYPE (arg_node) == N_funcall) ||
	      (NODE_TYPE (arg_node) == N_intconst) ||
	      (NODE_TYPE (arg_node) == N_monop) ||
	      (NODE_TYPE (arg_node) == N_variable));
  return (res);
}

static bool
isStatement (node * arg_node)
{
  bool res = ((NODE_TYPE (arg_node) == N_assign) ||
	      (NODE_TYPE (arg_node) == N_dowhile) ||
	      (NODE_TYPE (arg_node) == N_for) ||
	      (NODE_TYPE (arg_node) == N_if) ||
	      (NODE_TYPE (arg_node) == N_proccall) ||
	      (NODE_TYPE (arg_node) == N_return) ||
	      (NODE_TYPE (arg_node) == N_while));
  return (res);
}

void
isDummy ()
{
  isDec (NULL);
  isExpression (NULL);
  isStatement (NULL);
}

/** <!--******************************************************************-->
 *
 * @fn CHKassign
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Assign node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKassign (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKassign");

/*
 * Son check: ASSIGN_EXPRESSION 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (ASSIGN_EXPRESSION (arg_node), arg_node,
		   "mandatory son ASSIGN_EXPRESSION is NULL");
      if (ASSIGN_EXPRESSION (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpression (ASSIGN_EXPRESSION (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "ASSIGN_EXPRESSION hasnt the right type."
					 " It should be: "
					 "Nodeset: Expression");
	    }
	}
    }
  else
    {
      CHKnotExist (ASSIGN_EXPRESSION (arg_node), arg_node,
		   "attribute ASSIGN_EXPRESSION must be NULL");
    }

/*
 * Attribute check: ASSIGN_NAME
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (ASSIGN_NAME (arg_node), arg_node,
			 "mandatory attribute ASSIGN_NAME is NULL");
    }
  else
    {
      CHKnotExist (ASSIGN_NAME (arg_node), arg_node,
		   "attribute ASSIGN_NAME must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (ASSIGN_EXPRESSION (arg_node) != NULL)
    {
      ASSIGN_EXPRESSION (arg_node) =
	TRAVdo (ASSIGN_EXPRESSION (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKbinop
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node BinOp node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKbinop (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKbinop");

/*
 * Son check: BINOP_LEFT 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (BINOP_LEFT (arg_node), arg_node,
		   "mandatory son BINOP_LEFT is NULL");
      if (BINOP_LEFT (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpression (BINOP_LEFT (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "BINOP_LEFT hasnt the right type."
					 " It should be: "
					 "Nodeset: Expression");
	    }
	}
    }
  else
    {
      CHKnotExist (BINOP_LEFT (arg_node), arg_node,
		   "attribute BINOP_LEFT must be NULL");
    }

/*
 * Son check: BINOP_RIGHT 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (BINOP_RIGHT (arg_node), arg_node,
		   "mandatory son BINOP_RIGHT is NULL");
      if (BINOP_RIGHT (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpression (BINOP_RIGHT (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "BINOP_RIGHT hasnt the right type."
					 " It should be: "
					 "Nodeset: Expression");
	    }
	}
    }
  else
    {
      CHKnotExist (BINOP_RIGHT (arg_node), arg_node,
		   "attribute BINOP_RIGHT must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (BINOP_LEFT (arg_node) != NULL)
    {
      BINOP_LEFT (arg_node) = TRAVdo (BINOP_LEFT (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (BINOP_RIGHT (arg_node) != NULL)
    {
      BINOP_RIGHT (arg_node) = TRAVdo (BINOP_RIGHT (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKblock
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Block node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKblock (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKblock");

/*
 * Son check: BLOCK_NEXT 
 */
  if ((FALSE) || (TRUE))
    {
      if (BLOCK_NEXT (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (BLOCK_NEXT (arg_node)) == N_block)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "BLOCK_NEXT hasnt the right type."
					 " It should be: " "N_block");
	    }
	}
    }
  else
    {
      CHKnotExist (BLOCK_NEXT (arg_node), arg_node,
		   "attribute BLOCK_NEXT must be NULL");
    }

/*
 * Son check: BLOCK_THIS 
 */
  if ((FALSE) || (TRUE))
    {
      if (BLOCK_THIS (arg_node) != NULL)
	{
	  if (!((FALSE) || (isStatement (BLOCK_THIS (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "BLOCK_THIS hasnt the right type."
					 " It should be: "
					 "Nodeset: Statement");
	    }
	}
    }
  else
    {
      CHKnotExist (BLOCK_THIS (arg_node), arg_node,
		   "attribute BLOCK_THIS must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (BLOCK_NEXT (arg_node) != NULL)
    {
      BLOCK_NEXT (arg_node) = TRAVdo (BLOCK_NEXT (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (BLOCK_THIS (arg_node) != NULL)
    {
      BLOCK_THIS (arg_node) = TRAVdo (BLOCK_THIS (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKboolconst
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node BoolConst node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKboolconst (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKboolconst");
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKcast
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Cast node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKcast (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKcast");

/*
 * Son check: CAST_EXPRESSION 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (CAST_EXPRESSION (arg_node), arg_node,
		   "mandatory son CAST_EXPRESSION is NULL");
      if (CAST_EXPRESSION (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpression (CAST_EXPRESSION (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "CAST_EXPRESSION hasnt the right type."
					 " It should be: "
					 "Nodeset: Expression");
	    }
	}
    }
  else
    {
      CHKnotExist (CAST_EXPRESSION (arg_node), arg_node,
		   "attribute CAST_EXPRESSION must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (CAST_EXPRESSION (arg_node) != NULL)
    {
      CAST_EXPRESSION (arg_node) =
	TRAVdo (CAST_EXPRESSION (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKdecblock
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node DecBlock node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKdecblock (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKdecblock");

/*
 * Son check: DECBLOCK_NEXT 
 */
  if ((FALSE) || (TRUE))
    {
      if (DECBLOCK_NEXT (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (DECBLOCK_NEXT (arg_node)) == N_decblock)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "DECBLOCK_NEXT hasnt the right type."
					 " It should be: " "N_decblock");
	    }
	}
    }
  else
    {
      CHKnotExist (DECBLOCK_NEXT (arg_node), arg_node,
		   "attribute DECBLOCK_NEXT must be NULL");
    }

/*
 * Son check: DECBLOCK_THIS 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (DECBLOCK_THIS (arg_node), arg_node,
		   "mandatory son DECBLOCK_THIS is NULL");
      if (DECBLOCK_THIS (arg_node) != NULL)
	{
	  if (!((FALSE) || (isDec (DECBLOCK_THIS (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "DECBLOCK_THIS hasnt the right type."
					 " It should be: " "Nodeset: Dec");
	    }
	}
    }
  else
    {
      CHKnotExist (DECBLOCK_THIS (arg_node), arg_node,
		   "attribute DECBLOCK_THIS must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (DECBLOCK_NEXT (arg_node) != NULL)
    {
      DECBLOCK_NEXT (arg_node) = TRAVdo (DECBLOCK_NEXT (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (DECBLOCK_THIS (arg_node) != NULL)
    {
      DECBLOCK_THIS (arg_node) = TRAVdo (DECBLOCK_THIS (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKdowhile
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node DoWhile node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKdowhile (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKdowhile");

/*
 * Son check: DOWHILE_BODY 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (DOWHILE_BODY (arg_node), arg_node,
		   "mandatory son DOWHILE_BODY is NULL");
      if (DOWHILE_BODY (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (DOWHILE_BODY (arg_node)) == N_block)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "DOWHILE_BODY hasnt the right type."
					 " It should be: " "N_block");
	    }
	}
    }
  else
    {
      CHKnotExist (DOWHILE_BODY (arg_node), arg_node,
		   "attribute DOWHILE_BODY must be NULL");
    }

/*
 * Son check: DOWHILE_CONDITION 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (DOWHILE_CONDITION (arg_node), arg_node,
		   "mandatory son DOWHILE_CONDITION is NULL");
      if (DOWHILE_CONDITION (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpression (DOWHILE_CONDITION (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "DOWHILE_CONDITION hasnt the right type."
					 " It should be: "
					 "Nodeset: Expression");
	    }
	}
    }
  else
    {
      CHKnotExist (DOWHILE_CONDITION (arg_node), arg_node,
		   "attribute DOWHILE_CONDITION must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (DOWHILE_BODY (arg_node) != NULL)
    {
      DOWHILE_BODY (arg_node) = TRAVdo (DOWHILE_BODY (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (DOWHILE_CONDITION (arg_node) != NULL)
    {
      DOWHILE_CONDITION (arg_node) =
	TRAVdo (DOWHILE_CONDITION (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKfloatconst
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node FloatConst node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKfloatconst (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKfloatconst");
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKfor
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node For node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKfor (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKfor");

/*
 * Son check: FOR_BODY 
 */
  if ((FALSE) || (TRUE))
    {
      if (FOR_BODY (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (FOR_BODY (arg_node)) == N_block)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FOR_BODY hasnt the right type."
					 " It should be: " "N_block");
	    }
	}
    }
  else
    {
      CHKnotExist (FOR_BODY (arg_node), arg_node,
		   "attribute FOR_BODY must be NULL");
    }

/*
 * Son check: FOR_START 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (FOR_START (arg_node), arg_node,
		   "mandatory son FOR_START is NULL");
      if (FOR_START (arg_node) != NULL)
	{
	  if (!
	      ((FALSE) || (NODE_TYPE (FOR_START (arg_node)) == N_expression)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FOR_START hasnt the right type."
					 " It should be: " "N_expression");
	    }
	}
    }
  else
    {
      CHKnotExist (FOR_START (arg_node), arg_node,
		   "attribute FOR_START must be NULL");
    }

/*
 * Son check: FOR_STEP 
 */
  if ((FALSE) || (TRUE))
    {
      if (FOR_STEP (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (FOR_STEP (arg_node)) == N_expression)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FOR_STEP hasnt the right type."
					 " It should be: " "N_expression");
	    }
	}
    }
  else
    {
      CHKnotExist (FOR_STEP (arg_node), arg_node,
		   "attribute FOR_STEP must be NULL");
    }

/*
 * Son check: FOR_STOP 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (FOR_STOP (arg_node), arg_node,
		   "mandatory son FOR_STOP is NULL");
      if (FOR_STOP (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (FOR_STOP (arg_node)) == N_expression)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FOR_STOP hasnt the right type."
					 " It should be: " "N_expression");
	    }
	}
    }
  else
    {
      CHKnotExist (FOR_STOP (arg_node), arg_node,
		   "attribute FOR_STOP must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (FOR_BODY (arg_node) != NULL)
    {
      FOR_BODY (arg_node) = TRAVdo (FOR_BODY (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FOR_START (arg_node) != NULL)
    {
      FOR_START (arg_node) = TRAVdo (FOR_START (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FOR_STEP (arg_node) != NULL)
    {
      FOR_STEP (arg_node) = TRAVdo (FOR_STEP (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FOR_STOP (arg_node) != NULL)
    {
      FOR_STOP (arg_node) = TRAVdo (FOR_STOP (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKfunargs
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node FunArgs node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKfunargs (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKfunargs");

/*
 * Son check: FUNARGS_NEXT 
 */
  if ((FALSE) || (TRUE))
    {
      if (FUNARGS_NEXT (arg_node) != NULL)
	{
	  if (!
	      ((FALSE) || (NODE_TYPE (FUNARGS_NEXT (arg_node)) == N_funargs)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNARGS_NEXT hasnt the right type."
					 " It should be: " "N_funargs");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNARGS_NEXT (arg_node), arg_node,
		   "attribute FUNARGS_NEXT must be NULL");
    }

/*
 * Son check: FUNARGS_THIS 
 */
  if ((FALSE) || (TRUE))
    {
      if (FUNARGS_THIS (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpression (FUNARGS_THIS (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNARGS_THIS hasnt the right type."
					 " It should be: "
					 "Nodeset: Expression");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNARGS_THIS (arg_node), arg_node,
		   "attribute FUNARGS_THIS must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (FUNARGS_NEXT (arg_node) != NULL)
    {
      FUNARGS_NEXT (arg_node) = TRAVdo (FUNARGS_NEXT (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FUNARGS_THIS (arg_node) != NULL)
    {
      FUNARGS_THIS (arg_node) = TRAVdo (FUNARGS_THIS (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKfunbody
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node FunBody node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKfunbody (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKfunbody");

/*
 * Son check: FUNBODY_DECLARATIONS 
 */
  if ((FALSE) || (TRUE))
    {
      if (FUNBODY_DECLARATIONS (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (FUNBODY_DECLARATIONS (arg_node)) ==
		   N_decblock)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNBODY_DECLARATIONS hasnt the right type."
					 " It should be: " "N_decblock");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNBODY_DECLARATIONS (arg_node), arg_node,
		   "attribute FUNBODY_DECLARATIONS must be NULL");
    }

/*
 * Son check: FUNBODY_STATEMENTS 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (FUNBODY_STATEMENTS (arg_node), arg_node,
		   "mandatory son FUNBODY_STATEMENTS is NULL");
      if (FUNBODY_STATEMENTS (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (FUNBODY_STATEMENTS (arg_node)) == N_block)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNBODY_STATEMENTS hasnt the right type."
					 " It should be: " "N_block");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNBODY_STATEMENTS (arg_node), arg_node,
		   "attribute FUNBODY_STATEMENTS must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (FUNBODY_DECLARATIONS (arg_node) != NULL)
    {
      FUNBODY_DECLARATIONS (arg_node) =
	TRAVdo (FUNBODY_DECLARATIONS (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FUNBODY_STATEMENTS (arg_node) != NULL)
    {
      FUNBODY_STATEMENTS (arg_node) =
	TRAVdo (FUNBODY_STATEMENTS (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKfuncall
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node FunCall node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKfuncall (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKfuncall");

/*
 * Son check: FUNCALL_ARGS 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (FUNCALL_ARGS (arg_node), arg_node,
		   "mandatory son FUNCALL_ARGS is NULL");
      if (FUNCALL_ARGS (arg_node) != NULL)
	{
	  if (!
	      ((FALSE) || (NODE_TYPE (FUNCALL_ARGS (arg_node)) == N_funargs)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNCALL_ARGS hasnt the right type."
					 " It should be: " "N_funargs");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNCALL_ARGS (arg_node), arg_node,
		   "attribute FUNCALL_ARGS must be NULL");
    }

/*
 * Attribute check: FUNCALL_NAME
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (FUNCALL_NAME (arg_node), arg_node,
			 "mandatory attribute FUNCALL_NAME is NULL");
    }
  else
    {
      CHKnotExist (FUNCALL_NAME (arg_node), arg_node,
		   "attribute FUNCALL_NAME must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (FUNCALL_ARGS (arg_node) != NULL)
    {
      FUNCALL_ARGS (arg_node) = TRAVdo (FUNCALL_ARGS (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKfundec
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node FunDec node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKfundec (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKfundec");

/*
 * Son check: FUNDEC_BODY 
 */
  if ((FALSE) || (TRUE))
    {
      if (FUNDEC_BODY (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (FUNDEC_BODY (arg_node)) == N_funbody)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNDEC_BODY hasnt the right type."
					 " It should be: " "N_funbody");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNDEC_BODY (arg_node), arg_node,
		   "attribute FUNDEC_BODY must be NULL");
    }

/*
 * Son check: FUNDEC_PARAMS 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (FUNDEC_PARAMS (arg_node), arg_node,
		   "mandatory son FUNDEC_PARAMS is NULL");
      if (FUNDEC_PARAMS (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (FUNDEC_PARAMS (arg_node)) == N_funparams)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNDEC_PARAMS hasnt the right type."
					 " It should be: " "N_funparams");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNDEC_PARAMS (arg_node), arg_node,
		   "attribute FUNDEC_PARAMS must be NULL");
    }

/*
 * Attribute check: FUNDEC_NAME
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (FUNDEC_NAME (arg_node), arg_node,
			 "mandatory attribute FUNDEC_NAME is NULL");
    }
  else
    {
      CHKnotExist (FUNDEC_NAME (arg_node), arg_node,
		   "attribute FUNDEC_NAME must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (FUNDEC_BODY (arg_node) != NULL)
    {
      FUNDEC_BODY (arg_node) = TRAVdo (FUNDEC_BODY (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FUNDEC_PARAMS (arg_node) != NULL)
    {
      FUNDEC_PARAMS (arg_node) = TRAVdo (FUNDEC_PARAMS (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKfunparam
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node FunParam node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKfunparam (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKfunparam");

/*
 * Attribute check: FUNPARAM_NAME
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (FUNPARAM_NAME (arg_node), arg_node,
			 "mandatory attribute FUNPARAM_NAME is NULL");
    }
  else
    {
      CHKnotExist (FUNPARAM_NAME (arg_node), arg_node,
		   "attribute FUNPARAM_NAME must be NULL");
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKfunparams
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node FunParams node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKfunparams (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKfunparams");

/*
 * Son check: FUNPARAMS_NEXT 
 */
  if ((FALSE) || (TRUE))
    {
      if (FUNPARAMS_NEXT (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (FUNPARAMS_NEXT (arg_node)) == N_funparams)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNPARAMS_NEXT hasnt the right type."
					 " It should be: " "N_funparams");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNPARAMS_NEXT (arg_node), arg_node,
		   "attribute FUNPARAMS_NEXT must be NULL");
    }

/*
 * Son check: FUNPARAMS_THIS 
 */
  if ((FALSE) || (TRUE))
    {
      if (FUNPARAMS_THIS (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (FUNPARAMS_THIS (arg_node)) == N_funparam)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNPARAMS_THIS hasnt the right type."
					 " It should be: " "N_funparam");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNPARAMS_THIS (arg_node), arg_node,
		   "attribute FUNPARAMS_THIS must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (FUNPARAMS_NEXT (arg_node) != NULL)
    {
      FUNPARAMS_NEXT (arg_node) =
	TRAVdo (FUNPARAMS_NEXT (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FUNPARAMS_THIS (arg_node) != NULL)
    {
      FUNPARAMS_THIS (arg_node) =
	TRAVdo (FUNPARAMS_THIS (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKif
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node If node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKif (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKif");

/*
 * Son check: IF_CONDITION 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (IF_CONDITION (arg_node), arg_node,
		   "mandatory son IF_CONDITION is NULL");
      if (IF_CONDITION (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpression (IF_CONDITION (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "IF_CONDITION hasnt the right type."
					 " It should be: "
					 "Nodeset: Expression");
	    }
	}
    }
  else
    {
      CHKnotExist (IF_CONDITION (arg_node), arg_node,
		   "attribute IF_CONDITION must be NULL");
    }

/*
 * Son check: IF_ELSE 
 */
  if ((FALSE) || (TRUE))
    {
      if (IF_ELSE (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (IF_ELSE (arg_node)) == N_block)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "IF_ELSE hasnt the right type."
					 " It should be: " "N_block");
	    }
	}
    }
  else
    {
      CHKnotExist (IF_ELSE (arg_node), arg_node,
		   "attribute IF_ELSE must be NULL");
    }

/*
 * Son check: IF_THEN 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (IF_THEN (arg_node), arg_node,
		   "mandatory son IF_THEN is NULL");
      if (IF_THEN (arg_node) != NULL)
	{
	  if (!((FALSE) || (isBlock (IF_THEN (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "IF_THEN hasnt the right type."
					 " It should be: " "Nodeset: Block");
	    }
	}
    }
  else
    {
      CHKnotExist (IF_THEN (arg_node), arg_node,
		   "attribute IF_THEN must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (IF_CONDITION (arg_node) != NULL)
    {
      IF_CONDITION (arg_node) = TRAVdo (IF_CONDITION (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (IF_ELSE (arg_node) != NULL)
    {
      IF_ELSE (arg_node) = TRAVdo (IF_ELSE (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (IF_THEN (arg_node) != NULL)
    {
      IF_THEN (arg_node) = TRAVdo (IF_THEN (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKintconst
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node IntConst node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKintconst (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKintconst");
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKmodule
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Module node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKmodule (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKmodule");

/*
 * Son check: MODULE_DECLARATIONS 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (MODULE_DECLARATIONS (arg_node), arg_node,
		   "mandatory son MODULE_DECLARATIONS is NULL");
      if (MODULE_DECLARATIONS (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (MODULE_DECLARATIONS (arg_node)) == N_decblock)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "MODULE_DECLARATIONS hasnt the right type."
					 " It should be: " "N_decblock");
	    }
	}
    }
  else
    {
      CHKnotExist (MODULE_DECLARATIONS (arg_node), arg_node,
		   "attribute MODULE_DECLARATIONS must be NULL");
    }

/*
 * Attribute check: MODULE_NAME
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (MODULE_NAME (arg_node), arg_node,
			 "mandatory attribute MODULE_NAME is NULL");
    }
  else
    {
      CHKnotExist (MODULE_NAME (arg_node), arg_node,
		   "attribute MODULE_NAME must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (MODULE_DECLARATIONS (arg_node) != NULL)
    {
      MODULE_DECLARATIONS (arg_node) =
	TRAVdo (MODULE_DECLARATIONS (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKmonop
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node MonOp node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKmonop (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKmonop");

/*
 * Son check: MONOP_OPERAND 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (MONOP_OPERAND (arg_node), arg_node,
		   "mandatory son MONOP_OPERAND is NULL");
      if (MONOP_OPERAND (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpression (MONOP_OPERAND (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "MONOP_OPERAND hasnt the right type."
					 " It should be: "
					 "Nodeset: Expression");
	    }
	}
    }
  else
    {
      CHKnotExist (MONOP_OPERAND (arg_node), arg_node,
		   "attribute MONOP_OPERAND must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (MONOP_OPERAND (arg_node) != NULL)
    {
      MONOP_OPERAND (arg_node) = TRAVdo (MONOP_OPERAND (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKproccall
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node ProcCall node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKproccall (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKproccall");

/*
 * Son check: PROCCALL_ARGS 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (PROCCALL_ARGS (arg_node), arg_node,
		   "mandatory son PROCCALL_ARGS is NULL");
      if (PROCCALL_ARGS (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (PROCCALL_ARGS (arg_node)) == N_funargs)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "PROCCALL_ARGS hasnt the right type."
					 " It should be: " "N_funargs");
	    }
	}
    }
  else
    {
      CHKnotExist (PROCCALL_ARGS (arg_node), arg_node,
		   "attribute PROCCALL_ARGS must be NULL");
    }

/*
 * Attribute check: PROCCALL_NAME
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (PROCCALL_NAME (arg_node), arg_node,
			 "mandatory attribute PROCCALL_NAME is NULL");
    }
  else
    {
      CHKnotExist (PROCCALL_NAME (arg_node), arg_node,
		   "attribute PROCCALL_NAME must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (PROCCALL_ARGS (arg_node) != NULL)
    {
      PROCCALL_ARGS (arg_node) = TRAVdo (PROCCALL_ARGS (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKreturn
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Return node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKreturn (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKreturn");

/*
 * Son check: RETURN_EXPRESSION 
 */
  if ((FALSE) || (TRUE))
    {
      if (RETURN_EXPRESSION (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpression (RETURN_EXPRESSION (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "RETURN_EXPRESSION hasnt the right type."
					 " It should be: "
					 "Nodeset: Expression");
	    }
	}
    }
  else
    {
      CHKnotExist (RETURN_EXPRESSION (arg_node), arg_node,
		   "attribute RETURN_EXPRESSION must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (RETURN_EXPRESSION (arg_node) != NULL)
    {
      RETURN_EXPRESSION (arg_node) =
	TRAVdo (RETURN_EXPRESSION (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKvardec
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node VarDec node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKvardec (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKvardec");

/*
 * Son check: VARDEC_EXPRESSION 
 */
  if ((FALSE) || (TRUE))
    {
      if (VARDEC_EXPRESSION (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpression (VARDEC_EXPRESSION (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "VARDEC_EXPRESSION hasnt the right type."
					 " It should be: "
					 "Nodeset: Expression");
	    }
	}
    }
  else
    {
      CHKnotExist (VARDEC_EXPRESSION (arg_node), arg_node,
		   "attribute VARDEC_EXPRESSION must be NULL");
    }

/*
 * Attribute check: VARDEC_NAME
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (VARDEC_NAME (arg_node), arg_node,
			 "mandatory attribute VARDEC_NAME is NULL");
    }
  else
    {
      CHKnotExist (VARDEC_NAME (arg_node), arg_node,
		   "attribute VARDEC_NAME must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (VARDEC_EXPRESSION (arg_node) != NULL)
    {
      VARDEC_EXPRESSION (arg_node) =
	TRAVdo (VARDEC_EXPRESSION (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKvariable
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Variable node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKvariable (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKvariable");

/*
 * Attribute check: VARIABLE_NAME
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (VARIABLE_NAME (arg_node), arg_node,
			 "mandatory attribute VARIABLE_NAME is NULL");
    }
  else
    {
      CHKnotExist (VARIABLE_NAME (arg_node), arg_node,
		   "attribute VARIABLE_NAME must be NULL");
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKwhile
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node While node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKwhile (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKwhile");

/*
 * Son check: WHILE_BODY 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (WHILE_BODY (arg_node), arg_node,
		   "mandatory son WHILE_BODY is NULL");
      if (WHILE_BODY (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (WHILE_BODY (arg_node)) == N_block)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "WHILE_BODY hasnt the right type."
					 " It should be: " "N_block");
	    }
	}
    }
  else
    {
      CHKnotExist (WHILE_BODY (arg_node), arg_node,
		   "attribute WHILE_BODY must be NULL");
    }

/*
 * Son check: WHILE_CONDITION 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (WHILE_CONDITION (arg_node), arg_node,
		   "mandatory son WHILE_CONDITION is NULL");
      if (WHILE_CONDITION (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpression (WHILE_CONDITION (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "WHILE_CONDITION hasnt the right type."
					 " It should be: "
					 "Nodeset: Expression");
	    }
	}
    }
  else
    {
      CHKnotExist (WHILE_CONDITION (arg_node), arg_node,
		   "attribute WHILE_CONDITION must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (WHILE_BODY (arg_node) != NULL)
    {
      WHILE_BODY (arg_node) = TRAVdo (WHILE_BODY (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (WHILE_CONDITION (arg_node) != NULL)
    {
      WHILE_CONDITION (arg_node) =
	TRAVdo (WHILE_CONDITION (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

typedef enum
{ CHK_assign_name,
  CHK_binop_operator,
  CHK_boolconst_value,
  CHK_cast_type,
  CHK_floatconst_value,
  CHK_funcall_name,
  CHK_fundec_name,
  CHK_funparam_name,
  CHK_intconst_value,
  CHK_module_name,
  CHK_monop_operator,
  CHK_proccall_name,
  CHK_vardec_name,
  CHK_variable_name,
} attr_list;
